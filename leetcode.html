<!DOCTYPE html>
<html lang="en">

<head>
    <title>CGCL</title>
      <!-- Required meta tags always come first -->
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
  
      <!-- Bootstrap CSS -->
      <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
      <link rel="stylesheet" href="./styles.css">
     
</head>

<body>
    <nav class="navbar navbar-dark navbar-expand-sm fixed-top ">
        <div class="container ">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#Navbar">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand mr-auto" href="#">CGCL</a>

            <div class="collapse navbar-collapse " id="Navbar">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item active"><a class="nav-link" href="./gfg.html">Home</a> </li>
                <li class="nav-item"><a class="nav-link" href="#">codechef</a> </li>
                <li class="nav-item"><a class="nav-link" href="#">codeforces</a></li>
                <li class="nav-item"><a class="nav-link" href="./leetcode.html">Leetcode</a> </li>
            </ul>
            </div>
   
        </div>
       </nav>
    <header class="jumbotron">
        <div class="container">
            <div class="row row-header">
                <div class="col-12 col-sm-6">
                    <h1>CGCL</h1>
                    <p>Begineer to Advance</p>
                </div>
                </div>
            </div>
        </div>
        

    </header>
    </div>

    <div class="container problem-1">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 1</h2>
                <a href="https://leetcode.com/problems/gas-station/">Gas Station</a><br>
                
            </div>
               
        </div>      
        <div class="row">
           <div class="col-12 col-sm-6">
               <h3>Algorithm</h3>
               <p><i>This is a brute force approch having time complexity
                of O(n*n).we are starting from that index which give postitve result
                when we subract gas[i]-cost[i].And after that we are just follow a circluar path.</i>
               </p>
            <pre class='brush: cpp'>
                class Solution {
                    public:
                        int canCompleteCircuit(vector&lt;int&gt;& gas, vector&lt;int&gt;& cost) {
                            int n=gas.size();
                            vector&lt;int&gt; v(cost.size(),0);
                            for(int i=0;i&ltcost.size();i++){
                                v[i]=gas[i]-cost[i];
                            }
                            for(int i=0;i&lt;gas.size();i++){
                                int sum=v[i];
                                int j=(i+1)%n;
                                while(sum&gt;0&&j!=i){
                                    sum=sum+gas[j]-cost[j];
                                    j++;
                                    j=j%n;
                                }
                                if(j==i&&sum&gt;=0)return i;
                            }
                            return -1;
                        }
                    };
                </pre>
            </div>
            <div class="col-12 col-sm-6">
                <h3>Algorithm </h3>
                <p><i>Time complexity of this approch is O(n).In this we are maintaing
                    a vector which contains total gas upto that index.The maintaining of 
                    is necessary for not traversing the previous element again.we just
                    add the v[index-1]+gas[index]-cost[index] if it is greater than equal to zero
                    it means from this point we can make a circular path.</i>
                </p>
                <pre>
                    
                    class Solution {
                        public:
                            int canCompleteCircuit(vector&lt;int&gt;& gas, vector&lt;int&gt;& cost) {
                                int n=gas.size();
                                int required_gas=0;
                                int total_gas=0;
                                int index=0;
                                vector&lt;int&gt; v(n,0);
                                v[0]=gas[0]-cost[0];
                                for(int i=0;i&lt;gas.size();i++){
                                    required_gas=required_gas+gas[i]-cost[i];
                                    if(required_gas&lt;0){
                                        index=i+1;
                                      
                                        //the poin behind this can not take part //because they did not have sufficient gas to reach
                                        required_gas=0;
                                        
                                    }
                                    if(i&gt;=1)
                                    v[i]=v[i-1]+gas[i]-cost[i];
                                    
                                }
                                if(index==0&&required_gas&gt;=0)return index;
                                if(v[index-1]+required_gas&gt;=0)return index;
                                
                                return -1;
                            }
                        };
                </pre>
            </div>
        </div> 
    </div>
    <div class="container problem-2">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 2</h2>
                <a href="https://leetcode.com/problems/shuffle-the-array/">Shuffel the array</a><br>
                
            </div>
               
        </div>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Algorithm</h3>
                <p><i>This is a simple question in which given 2n elements.
                    so we simply divide go to nth element and then add one 
                    element in vector from starting and one from the nth position.</i>
                </p>
             <pre>
                class Solution {
                    public:
                        vector&lt;int&gt; shuffle(vector&lt;int&gt;& nums, int n) {
                            
                            int k=nums.size();
                            int j=k/2;
                            int aptr=0;
                            int bptr=j;
                            int m=0;
                           /* while(i&lt;(k-2)){
                                swap(nums,i,j);
                                i++;
                                if(i==j)
                                    j++;
                                
                            }*/
                            vector&lt;int&gt; v=nums;
                            while(aptr&lt;j&&bptr&lt;2*n){
                                v[m++]=nums[aptr++];
                                v[m++]=nums[bptr++];
                                
                            }
                            return v;
                        }
                    
                    };
                 </pre>
             </div>
             <div class="col-12 col-sm-6">
                <h3>Algorithm </h3>
                <p><i>This solution take less time as compared to first.The concept of both is 
                    same.First we adding starting element then we adding the element at the nth position.</i>
                </p>
                <pre>
                    class Solution {
                        public:
                            vector&lt;int&gt; shuffle(vector&lt;int&gt;& nums, int n) {
                                vector&lt;int&gt; ans;
                                for(int i=0;i&lt;n;i++){
                                    ans.push_back(nums[i]);
                                    ans.push_back(nums[i+n]);
                                }
                                return ans;
                            }
                        };
                </pre>
            </div>
         
    </div>
    </div>
    <div class="container problem-3">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 3</h2>
                <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">Binary Tree Level Order Traversal II</a><br>
                
            </div>
               
        </div>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Algorithm</h3>
                <p><i>This is a simple question in which we simply do level order traversing and then 
                    reverse the vector</i>
                </p>
             <pre>
                class Solution {
                    public:
                        vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
                            vector&lt;vector&lt;int&gt;&gt; vec;
                            queue&lt;TreeNode*&gt; v;
                           // int i=0;
                            if(!root)
                                return vec;
                            
                            v.push(root);
                            while(!v.empty()){
                                 vector&lt;int&gt; v1;
                                int s=v.size();
                                while(s--){
                                   
                                
                                    TreeNode* node=v.front();
                                    v.pop();
                                    //int data=node-&gt;val
                                    v1.push_back(node-&gt;val);
                                    if(node-&gt;left!=NULL)
                                        v.push(node-&gt;left);
                                    if(node-&gt;right!=NULL)
                                        v.push(node-&gt;right);
                                }
                                vec.push_back(v1);
                            }
                            reverse(vec.begin(),vec.end());
                            return vec;
                        }
                    };
                 </pre>
             </div>
             <div class="col-12 col-sm-6">
                <h3>Algorithm </h3>
                <p><i>This solution take less time as compared to first.The concept of both is 
                    same.In this we use null pointer which reduce the time complexity.</i>
                </p>
                <pre>
                    class Solution {
                        public:
                            vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) 
                            {
                                queue&lt;TreeNode *&gt; q;
                            vector&lt;vector&lt;int&gt;&gt; result;
                            vector&lt;int&gt; arr;
                                if(root==NULL)
                                    return result;
                                q.push(root);
                                q.push(NULL);
                                while(!q.empty())
                                {
                                    TreeNode *t=q.front();
                                    q.pop();
                                    
                                    if(t==NULL)
                                    {
                                        result.push_back(arr);
                                        arr.resize(0);
                                        if(q.size()&gt;0)
                                            q.push(NULL);
                                        
                                    }
                                    else
                                    {
                                     arr.push_back(t-&gt;val) ;
                                     if(t-&gt;left!=NULL) q.push(t-&gt;left);
                                     if(t-&gt;right!=NULL) q.push(t-&gt;right);
                                        
                                    }
                                }
                                reverse(result.begin(),result.end());
                                return result;
                                
                                
                            }
                        };
                </pre>
            </div>
         
    </div>
    </div>
    <div class="container problem-4">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 4</h2>
                <a href="https://leetcode.com/problems/prison-cells-after-n-days/">Prison Cells After N Days</a><br>
                
            </div>
               
        </div>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Algorithm</h3>
                <p><i>so the 0th index and n-1 index remaining zero because they do not
                    have any neighbours and for the inner elments we have to check
                    (i-1)th and (i+1)th element.if they are same then ith element will 
                    be 1 else 0;</i>
                </p>
             <pre>
                class Solution {
                    public:
                        vector&lt;int&gt; prisonAfterNDays(vector&lt;int&gt;& cells, int N) {
                          map&lt;string,int&gt; mp;
                            vector&lt;int&gt; temp=cells;
                            int cycle=0;
                             
                            
                            while(1){
                                 for(int i=0;i&lt;cells.size();i++){
                                if(i==0||i==(cells.size()-1))
                                    temp[i]=0;
                                else if((cells[i-1]==1&&cells[i+1]==1)||(cells[i-1]==0&&cells[i+1]==0))
                                    temp[i]=1;
                                else
                                    temp[i]=0;
                                     
                                 }
                                
                                string str="";
                                for(int i=0;i&lt;cells.size();i++){
                                    str=str+to_string(temp[i]);
                                }
                                
                               
                               
                                if(mp.find(str)!=mp.end())
                                         break;
                                else
                                {
                                    cells=temp;
                                    mp[str]++;
                                    cycle++;
                                }
                                
                                
                            }
                            N=N%cycle;
                            while(N--){
                                for(int i=0;i&lt;cells.size();i++){
                                if(i==0||i==(cells.size()-1))
                                    temp[i]=0;
                                else if((cells[i-1]==1&&cells[i+1]==1)||(cells[i-1]==0&&cells[i+1]==0))
                                    temp[i]=1;
                                else
                                    temp[i]=0;
                                
                                
                            }
                                cells=temp;
                            }
                            return cells;
                        }
                    };
                 </pre>
             </div>
            
         
     </div>
    </div>
    
    <div class="container problem-5">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 5</h2>
                <a href="https://leetcode.com/problems/3sum/">3Sum</a><br>
                
            </div>
               
        </div>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Algorithm</h3>
                <p><i>First we have to sort the vector.after that we are considering the three position 
                    one is always point to the i-th index(as loop works) and second is always started from (i+1)th and 
                    third always started from last index.
                    when the array is sorted the small values always comes first.
                    so when we add all the three pointer and if we get answer less than 0.
                    it means we are negative values so we have to move the second pointer towards
                    the ending point.and vice versa if we get value greater than 0 it means we are 
                    adding greater valuse.so we have to move the third pointer towards the second pointer.
                    when they pass each other it means we are done with ith index and now its time to go
                    further.
                </i>
                </p>
             <pre>
                class Solution {
                    public:
                        vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;& nums) {
                            int i=0;
                            int n;
                            int k;
                            int size=nums.size();
                            vector&lt;int&gt; v;
                            vector&lt;vector&lt;int&gt;&gt; vec;
                            map&lt;vector&lt;int&gt;,int&gt; mp;
                            sort(nums.begin(),nums.end());
                            while(i&lt;(size-2)){
                                n=i+1;
                                k=nums.size()-1;
                                while(n&lt;k){
                                    if(nums[i]+nums[n]+nums[k]&lt;0)
                                        n++;
                                    else if(nums[i]+nums[n]+nums[k]&gt;0)
                                        k--;
                                    else{
                                        v.push_back(nums[i]);
                                        v.push_back(nums[n]);
                                        v.push_back(nums[k]);
                                        
                                        if(mp.find(v)==mp.end()){
                                        vec.push_back(v);
                                            mp[v]++;}
                                        v.clear();
                                        n++;
                                        k--;
                                    }
                                }
                                i++;
                            }
                            return vec;
                        }
                    };
                 </pre>
             </div>
             
    </div>
    </div>
    <div class="container problem-6">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 6</h2>
                <a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/">Flatten a Multilevel Doubly Linked List</a><br>
                
            </div>
               
        </div>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Algorithm</h3>
                <p><i>we traverse the list from head.whenever we get the node whose child is not equal to NULL.we 
                    traverse the child avoiding going further.Doing this we go always to the last element of that child
                    then we return the last node always.Then we make the lastNode=head-&gt;next.
                </i>
                </p>
             <pre>
                class Solution {
                    public:
                        Node * flatten1(Node *head){
                              if(head==NULL)return head;
                            if(head-&gt;next==NULL&&head-&gt;child==NULL)return head; 
                            
                            if(head-&gt;child){
                                Node *temp=flatten1(head-&gt;child);
                                temp-&gt;next=head-&gt;next;
                                if(head-&gt;next)head-&gt;next-&gt;prev=temp;
                                head-&gt;next=head-&gt;child;
                                if(head-&gt;child)head-&gt;child-&gt;prev=head;
                                head-&gt;child=NULL;
                                
                               if(temp-&gt;next!=NULL)
                                return flatten1(temp-&gt;next);
                            }
                           
                            return flatten1(head-&gt;next);
                            
                          
                        }
                        Node* flatten(Node* head) {
                            if(head==NULL)return head;
                            if(head-&gt;next==NULL&&!head-&gt;child)return head;
                            
                            
                            flatten1(head);
                            return head;
                           
                        }
                    };
                 </pre>
             </div>
             
    </div>
    </div>
    
    <div class="container problem-7">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 7</h2>
                <a href="https://leetcode.com/problems/detect-capital/">Detect Capital</a><br>
                
            </div>
               
        </div>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Algorithm</h3>
                <p><i>We have to consider the 0th and 1st index.If they both are uppercase then we have to check
                    that the rest must be greater.And if first is uppercase and second is lowercase then the rest 
                    must be lowercase.
                    If first is lowercase then rest must be lowercase.
                </i>
                </p>
             <pre>
                class Solution {
                    public:
                        bool Greater(string word){
                            if(word.size()==0)return true;
                            
                            int i=0;
                            if(word[i]&gt;='A'&&word[i]&lt;='Z'&&Greater(word.substr(i+1)))
                            return true;
                            else return false;
                                
                        }
                         bool Smaller(string word){
                            if(word.size()==0)return true;
                            
                            int i=0;
                            if(word[i]&gt;='a'&&word[i]&lt;='z'&&Smaller(word.substr(i+1)))
                            return true;
                            else return false;
                                
                        }
                        bool detectCapitalUse(string word) {
                            if(word.size()==0||word.size()==1)return true;
                            
                            if(word[0]&gt;='A'&&word[0]&lt;='Z'){
                                if(word[1]&gt;='A'&&word[1]&lt;='Z')return Greater(word.substr(2));
                                else return Smaller(word.substr(2));
                                
                            }
                            else return Smaller(word.substr(1));
                        }
                    };
                 </pre>
             </div>
             <div class="col-12 col-sm-6">
                <h3>Algorithm </h3>
                <p><i>The concept is same but this solution is not using recursive approch</i>
                </p>
                <pre>
                    class Solution {
                        public:
                            bool detectCapitalUse(string word) {
                                int n=word.length();
                                int i;
                                bool flag=false;
                                if(n==1)
                                    return true;
                                
                                for(i=0;i&lt;n;i++){
                                    if(isupper(word[i])){
                                        
                                        flag=true;
                                    }
                                    else{
                                        flag=false;
                                        break;
                                    }
                                }
                                if(flag==true)
                                    return flag;
                                else
                                    i=1;
                                
                                while(i&lt;n){
                                    if(islower(word[i])){
                                        i++;
                                        flag=true;
                                    }
                                    else {
                                        flag=false;
                                        break;
                                    }
                                }
                                return flag;
                            }
                        };
                </pre>
            </div>
         
    </div>
    </div>
    
    <div class="container problem-8">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 8</h2>
                <a href="https://leetcode.com/problems/design-hashset/">Design HashSet</a><br>
                
            </div>
               
        </div>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Algorithm</h3>
                <p><i>we are using a vector which is containing list.Because the hash value of two numbers can 
                    be same.2%5=2 and 7%5=2 so we are using list.
                </i>
                </p>
             <pre>
                class MyHashSet {
                    int prime;
                        vector&lt;list&lt;int&gt;&gt; table;
                    
                        int hash(int key) {
                            return key % prime;
                        }
                    
                        list&lt;int&gt;::iterator search(int key) {
                            int h = hash(key);
                            return find(table[h].begin(), table[h].end(), key);
                        }
                    
                    public:
                        MyHashSet() : prime(10000), table(prime) {}
                        
                        void add(int key) {
                            int h = hash(key);
                            if (!contains(key))
                                table[h].push_back(key);
                        }
                        
                        void remove(int key) {
                            int h = hash(key);
                            auto it = search(key);
                            if (it != table[h].end())
                                table[h].erase(it);
                        }
                        
                        bool contains(int key) {
                            int h = hash(key);
                            return search(key) != table[h].end();
                        }
                    };
                 </pre>
             </div>
             <div class="col-12 col-sm-6">
                <h3>Algorithm </h3>
                <p><i>First approch is better than this because the space complexity is high in this approch as 
                    compared to first one.
                </i>
                </p>
                <pre>
                    class MyHashSet {
                        public:
                            /** Initialize your data structure here. */
                            int n;
                            vector&lt;int&gt; vec;
                            MyHashSet() : n(1000001),vec(n,0){
                          
                            }
                            
                            void add(int key) {
                                vec[key]=1;
                            }
                            
                            void remove(int key) {
                                vec[key]=0;
                            }
                            
                            /** Returns true if this set contains the specified element */
                            bool contains(int key) {
                                if(vec[key]==1)return true;
                                else return false;
                            }
                        };
                        
                </pre>
            </div>
         
    </div>
    </div>
    
    <div class="container problem-9">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 9</h2>
                <a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/">Vertical Order Traversal of a Binary Tree</a><br>
                
            </div>
               
        </div>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Algorithm</h3>
                <p><i>we have to do vertical order traversal of the tree.The main point here is that we have
                    to sort vertical order according to their level.
                </i>
                </p>
             <pre>
                class Solution {
                    public:
                        void traverse(TreeNode  *root,map&lt;int,vector&lt;pair&lt;int,int&gt;&gt;&gt; &mp,int index,int level){
                            if(root==NULL)return ;
                            
                            mp[index].push_back({level,root-&gt;val});
                            traverse(root-&gt;left,mp,index-1,level+1);
                            traverse(root-&gt;right,mp,index+1,level+1);
                            return ;
                        }
                        vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) {
                            if(root==NULL)return {{}};
                            vector&lt;vector&lt;int&gt;&gt; vec;
                            vector&lt;int&gt; v;
                            map&lt;int,vector&lt;pair&lt;int,int&gt;&gt;&gt; mp;
                            traverse(root,mp,0,0);
                            for(auto itr=mp.begin();itr!=mp.end();itr++){
                               sort(itr-&gt;second.begin(),itr-&gt;second.end());
                               for(auto it=itr-&gt;second.begin();it!=itr-&gt;second.end();it++){
                                   v.push_back(it-&gt;second);
                               }
                                vec.push_back(v);
                                v.clear();
                            }
                            return vec;
                        }
                    };
                 </pre>
             </div>
             </div>
         
    </div>
    <div class="container problem-10">
        <div class="row ">
            <div class="col-12 col-sm-6">
                <h2>Problem 10</h2>
                <a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/">Find All Duplicates in an Array</a><br>
                
            </div>
               
        </div>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Algorithm</h3>
                <p><i>A big hint is given in the question.Question says the value of nums is lies between
                    (1 ≤ a[i] ≤ n ).so we use the value of arr as index.if u make closer look to the arr u find that whenever 
                    a same element appears again then a circular loop is formed.so this is best approch for solving this question.
                    so we use a loop from i=0 to i=nums.size() the index that are traversing through loop become 0 that is not
                    visited before.And the indexes that is visited through circular loop they become negative.
                    so the concept is simple whenever we find an index with index value -1.it means we are traversing it again.
                    so their is element that take us to same index again .so this is the element that is twice in the array.
                    Flag is used in the approch if somehow we are traversing the element that is traverse by the loop.we make that index
                    negative and flag become true.because their is no benefit to move further because the for loop traversed it already.
                </i>
                </p>
             <pre>
                 class Solution {
                public:
                    vector&lt;int&gt; findDuplicates(vector&lt;int&gt;& nums) {
                        int n=nums.size();
                        vector&lt;int&gt; v;
                        for(int i=0;i&lt;n;i++){
                            if(nums[i]!=-1&&nums[i]!=0){
                                int j=nums[i];
                                 nums[i]=0;
                                bool flag=false;
                                while(nums[j-1]!=-1){
                                    if(nums[j-1]==0){
                                        nums[j-1]=-1;
                                        flag=true;
                                        break;
                                    }
                                    int t=nums[j-1];
                                    nums[j-1]=-1;
                                    j=t;
                                }
                                if(!flag)
                                    v.push_back(j);
                            }
                           
                        }
                        return v;
                    }
                };
                 </pre>
             </div>
             </div>
         
    </div>
    <div class="container">
         <div class="row justify-content-end">
             <div class="col-3 col-sm-2">
                <a href="./leetcode2.html" class="btn btn-primary btn-lg" role="button" aria-disabled="true">Next</a>
             </div>
             
            
         </div>
    </div>


    <footer>
        <div class="container-fluid footer">
            <div class="row ">             
                <div class="col-4 offset-1 col-sm-2">
                    <h5>Links</h5>
                    <ul class="list-unstyled">
                        <li><a href="#">Home</a></li>
                        <li><a href="#">GeeksforGeeks</a></li>
                        <li><a href="#">codeforces</a></li>
                        <li><a href="#">Leetcode</a></li>
                    </ul>
                </div>
               
                <div class="col-8 col-sm-4 align-self-center">
                    <div >
                        <a href="http://google.com/+">Google+</a>
                        <a href="http://www.facebook.com/profile.php?id=">Facebook</a>
                        <a href="http://www.linkedin.com/in/">LinkedIn</a>
                        <a href="http://twitter.com/">Twitter</a>
                        <a href="http://youtube.com/">YouTube</a>
                        <a href="mailto:">Mail</a>
                    </div>
                </div>
           </div>
           <div class="row justify-content-center">             
                <div clas="col-auto">
                    <p>© Copyright 2021 make with love</p>
                </div>
           </div>
        </div>
    </footer>
       <!-- jQuery first, then Popper.js, then Bootstrap JS. -->
       <script src="node_modules/jquery/dist/jquery.slim.min.js"></script>
       <script src="node_modules/popper.js/dist/umd/popper.min.js"></script>
       <script src="node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
       
</body>

</html> 